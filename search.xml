<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux实战篇(五) - 网络配置、进程管理</title>
    <url>/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/</url>
    <content><![CDATA[<h3 id="1、Linux网络配置原理图（含虚拟机）"><a href="#1、Linux网络配置原理图（含虚拟机）" class="headerlink" title="1、Linux网络配置原理图（含虚拟机）"></a>1、Linux网络配置原理图（含虚拟机）</h3><img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114141316875.png" alt="image-20220114141316875" style="zoom:50%;">

<p>说明：Linux虚拟机和windows之间是通过windows的虚拟网卡(以太网适配器 VMware Network Adapter VMnet8) 构成了一个网络，它们之间可以进行通信。windows上有一个真实的网卡（可能是无线网卡，可能是物理网卡），这个真实的网卡再通过教室的网关就可以访问互联网。</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114142053767.png" alt="image-20220114142053767" style="zoom:50%;">



<h3 id="2、查看网络IP和网关"><a href="#2、查看网络IP和网关" class="headerlink" title="2、查看网络IP和网关"></a>2、查看网络IP和网关</h3><h4 id="1、修改ip地址-修改虚拟网络的-ip"><a href="#1、修改ip地址-修改虚拟网络的-ip" class="headerlink" title="1、修改ip地址 (修改虚拟网络的 ip)"></a>1、修改ip地址 (修改虚拟网络的 ip)</h4><p>​    编辑 - 》虚拟网络编辑器</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114142853278.png" alt="image-20220114142853278" style="zoom: 50%;">

<h4 id="2、查看网关"><a href="#2、查看网关" class="headerlink" title="2、查看网关"></a>2、查看网关</h4><img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114143453897.png" alt="image-20220114143453897" style="zoom:50%;">

<h4 id="3、查看-windows-环境的中-VMnet8-网络配置-ipconfig-指令"><a href="#3、查看-windows-环境的中-VMnet8-网络配置-ipconfig-指令" class="headerlink" title="3、查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)"></a>3、查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)</h4><p>​    1）使用ipconfig查看</p>
<p>​    2）界面查看</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114143855024.png" alt="image-20220114143855024" style="zoom:50%;">



<h3 id="3、linux网络环境配置"><a href="#3、linux网络环境配置" class="headerlink" title="3、linux网络环境配置"></a>3、linux网络环境配置</h3><h4 id="1、第一种方式（自动获取）"><a href="#1、第一种方式（自动获取）" class="headerlink" title="1、第一种方式（自动获取）"></a>1、第一种方式（自动获取）</h4><img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114152118193.png" alt="image-20220114152118193" style="zoom:50%;">

<p>缺点: linux 启动后会自动获取 IP,缺点是每次自动获取的 ip 地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip 需要时固定的。</p>
<h4 id="2、第二种方法-指定固定的-ip"><a href="#2、第二种方法-指定固定的-ip" class="headerlink" title="2、第二种方法(指定固定的 ip)"></a>2、第二种方法(指定固定的 ip)</h4><p>​           说明：直 接 修 改 配 置 文 件 来 指 定 IP, 并 可 以 连 接 到 外 网 ( 程 序 员 推 荐 ) ， </p>
<p>​            编 辑    vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114153149369.png" alt="image-20220114153149369" style="zoom:50%;">

<p>​            要求：将 ip 地址配置的静态的，ip 地址为 192.168.18.130</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114153854433.png" alt="image-20220114153854433" style="zoom:50%;">

<p>​                        <strong>修改后，一定要 重启服务</strong></p>
<p>​                            1)  service network restart</p>
<p>​                            2)  <strong>reboot 重启系统</strong></p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114155022581.png" alt="image-20220114155022581" style="zoom:50%;">



<h3 id="4、进程管理"><a href="#4、进程管理" class="headerlink" title="4、进程管理"></a>4、进程管理</h3><h4 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h4><p>​            查看进行使用的指令是   ps ,一般来说使用的参数是 ps -aux</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114160646075.png" alt="image-20220114160646075" style="zoom:40%;">

<h4 id="2、ps指令详解"><a href="#2、ps指令详解" class="headerlink" title="2、ps指令详解"></a>2、ps指令详解</h4><img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114160254658.png" alt="image-20220114160254658" style="zoom:50%;">



<h4 id="3、应用实例"><a href="#3、应用实例" class="headerlink" title="3、应用实例"></a>3、应用实例</h4><p>​    要求：以全格式显示当前所有的进程，查看进程的父进程。</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114161218408.png" alt="image-20220114161218408" style="zoom:50%;">



<h4 id="4、终止进程kill-和killall"><a href="#4、终止进程kill-和killall" class="headerlink" title="4、终止进程kill 和killall"></a>4、终止进程kill 和killall</h4><pre><code>  1、介绍
</code></pre>
<p>​            若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 <strong>kill 命令</strong>来完成此项任务。</p>
<p>​      2、基本语法</p>
<p>​                <strong>kill  [选项] 进程号（功能描述：通过进程号杀死进程）</strong></p>
<p>​                <strong>killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</strong></p>
<p>​       3、常用选项</p>
<p>​            <strong>-9 ： 表示强迫进程立即停止</strong></p>
<p>​        4、最佳实践</p>
<p>​            案例 1：踢掉某个非法登录用户</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114162515236.png" alt="image-20220114162515236" style="zoom:50%;">



<h4 id="5、查看进程树-pstree"><a href="#5、查看进程树-pstree" class="headerlink" title="5、查看进程树 pstree"></a>5、查看进程树 pstree</h4><p>1、基本语法：</p>
<p>​    pstree [选项] ,可以更加直观的来看进程信息</p>
<p>2、常用选项：</p>
<p>​        -p :显示进程的 PID</p>
<p>​        -u :显示进程的所属用户</p>
<h3 id="5、服务（service）管理"><a href="#5、服务（service）管理" class="headerlink" title="5、服务（service）管理"></a>5、服务（service）管理</h3><h4 id="1、服务介绍"><a href="#1、服务介绍" class="headerlink" title="1、服务介绍"></a>1、服务介绍</h4><p>​              服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114163744841.png" alt="image-20220114163744841" style="zoom:50%;">

<h4 id="2、telnet-测试某个端口是否可以访问"><a href="#2、telnet-测试某个端口是否可以访问" class="headerlink" title="2、telnet 测试某个端口是否可以访问"></a>2、telnet 测试某个端口是否可以访问</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet ip地址 端口号</span><br></pre></td></tr></table></figure>

<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114164746002.png" alt="image-20220114164746002" style="zoom:50%;">

<h4 id="3、查看服务名"><a href="#3、查看服务名" class="headerlink" title="3、查看服务名"></a>3、查看服务名</h4><p>​            1、/etc/init.d/服务名称</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%BA%94)/image-20220114165332327.png" alt="image-20220114165332327" style="zoom:50%;">]]></content>
  </entry>
  <entry>
    <title>Linux实战篇(三) - 组、权限rwx、任务调度</title>
    <url>/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/</url>
    <content><![CDATA[<h3 id="一、组管理"><a href="#一、组管理" class="headerlink" title="一、组管理"></a>一、组管理</h3><h4 id="1-Linux组基本介绍"><a href="#1-Linux组基本介绍" class="headerlink" title="1 Linux组基本介绍"></a>1 Linux组基本介绍</h4><p>​        在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p>
<ol>
<li><p> 所有者</p>
</li>
<li><p> 所在组</p>
</li>
<li><p> 其它组</p>
</li>
<li><p> 改变用户所在的组</p>
</li>
</ol>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113115813421.png" alt="image-20220113115813421" style="zoom: 50%;">

<h4 id="2-文件-目录-所有者"><a href="#2-文件-目录-所有者" class="headerlink" title="2 文件/目录 所有者"></a>2 文件/目录 所有者</h4><p>​    一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。</p>
<h5 id="2-1-查看文件的所有者"><a href="#2-1-查看文件的所有者" class="headerlink" title="2.1 查看文件的所有者"></a>2.1 查看文件的所有者</h5><p>​    1)  指令：<strong>ls  -ahl</strong></p>
<p>​    2)  应用实例：创建一个组 police,再创建一个用户 tom1,将 tom1 放在 police 组 ,然后使用 tom 来创建一个文件 ok.txt，看看情况如何</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113120216286.png" alt="image-20220113120216286" style="zoom: 50%;">

<p>使用tom1账号登录Linux</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113120755701.png" alt="image-20220113120755701" style="zoom:50%;">



<h5 id="2-2-修改文件所有者"><a href="#2-2-修改文件所有者" class="headerlink" title="2.2    修改文件所有者"></a>2.2    修改文件所有者</h5><p>•  指令：chown 用户名 文件名</p>
<p>•  应用案例</p>
<p>要求：使用 root 创建一个文件 apple.txt ，然后将其所有者修改成 tom</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113143214132.png" alt="image-20220113143214132" style="zoom: 50%;">



<h5 id="2-3-查看文件-目录所在组"><a href="#2-3-查看文件-目录所在组" class="headerlink" title="2.3    查看文件/目录所在组"></a>2.3    查看文件/目录所在组</h5><p>​    基本指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls –ahl</span><br></pre></td></tr></table></figure>

<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113144219416.png" alt="image-20220113144219416" style="zoom:50%;">

<h5 id="2-4-修改文件所在的组"><a href="#2-4-修改文件所在的组" class="headerlink" title="2.4    修改文件所在的组"></a>2.4    修改文件所在的组</h5><p>•  基本指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure>

<p>•  应用实例<br> 使用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 police 组 。</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113143859564.png" alt="image-20220113143859564" style="zoom: 50%;">



<h5 id="2-5-改变用户所在组"><a href="#2-5-改变用户所在组" class="headerlink" title="2.5    改变用户所在组"></a>2.5    改变用户所在组</h5><p>​        1)  <strong>usermod   –g    组名   用户名</strong></p>
<p>​        2）usermod -d 目录名 用户名    改变该用户登录的初始目录</p>
<p>​      <strong>应用实例：</strong></p>
<p>​        创建一个土匪组（bandit）将tom这个用户从原来所在的police组，修改到bandit组</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113145405857.png" alt="image-20220113145405857" style="zoom:50%;">



<h3 id="二、权限详解"><a href="#二、权限详解" class="headerlink" title="二、权限详解"></a>二、权限详解</h3><h4 id="1、权限的基本介绍"><a href="#1、权限的基本介绍" class="headerlink" title="1、权限的基本介绍"></a>1、权限的基本介绍</h4><p>​    ls -l 显示的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r--. 1 tom bandit 0 Jan 13 19:42 ok.txt</span><br></pre></td></tr></table></figure>

<p>0-9 位说明</p>
<ol>
<li>第 0 位确定文件类型(d, - , l , c , b)</li>
</ol>
<p>​        - ：普通文件     d: 目录     l：软链接      c：字符设备[键盘，鼠标]     b：块文件[硬盘]</p>
<ol start="2">
<li><p>第 1-3 位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限。—User</p>
</li>
<li><p>第 4-6 位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限，—Group</p>
</li>
<li><p>第 7-9 位确定其他用户拥有该文件的权限 —Other</p>
</li>
</ol>
<p>5）第10位 如果是文件，表示硬链接的数，如果是目录则表示该目录的子目录个数</p>
<h4 id="2、rwx权限详解"><a href="#2、rwx权限详解" class="headerlink" title="2、rwx权限详解"></a>2、rwx权限详解</h4><h5 id="2-1-rwx-作用到文件"><a href="#2-1-rwx-作用到文件" class="headerlink" title="2.1 rwx 作用到文件"></a>2.1 rwx 作用到文件</h5><ol>
<li><p> [ r ]代表可读(read): 可以读取,查看</p>
</li>
<li><p> [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p>
</li>
<li><p> [ x ]代表可执行(execute):可以被执行</p>
</li>
</ol>
<h5 id="2-2-rwx-作用到目录"><a href="#2-2-rwx-作用到目录" class="headerlink" title="2.2  rwx 作用到目录"></a>2.2  rwx 作用到目录</h5><ol>
<li><p>[ r ]代表可读(read): 可以读取，ls 查看目录内容</p>
</li>
<li><p>[ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录</p>
</li>
<li><p>[ x ]代表可执行(execute):可以进入该目录</p>
</li>
</ol>
<h5 id="2-3-文件及目录权限实际案例【必须记住】"><a href="#2-3-文件及目录权限实际案例【必须记住】" class="headerlink" title="2.3 文件及目录权限实际案例【必须记住】"></a>2.3 文件及目录权限实际案例【必须记住】</h5><p>ls  -l 中显示的内容如下：(记住)</p>
<p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p>
<p>10 个字符确定不同用户能对文件干什么</p>
<p>​        1）第一个字符代表文件类型： 文件 (-),目录(d),链接(l)</p>
<p>​        其余字符每 3 个一组(rwx) <strong>读(r) 写(w) 执行(x)</strong> </p>
<p>​        2）第一组 rwx : 文件拥有者的权限是读、写和执行</p>
<p>​        3）第二组 rw- :  与文件拥有者同一组的用户的权限是读、写但不能执行</p>
<p>​        4）第三组 r– :  不与文件拥有者同组的其他用户的权限是读不能写和执行可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7</p>
<p>​        5） 1    文件：硬连接数或   目录：子目录数</p>
<p>​        6）root           用户</p>
<p>​        7）root           组</p>
<p>​        8）1213          文件大小(字节)，如果是文件夹，显示 4096 字节</p>
<p>​        9）Feb 2 09:39     最后修改日期</p>
<p>​        10）abc        文件名</p>
<h4 id="3、修改权限-chmod"><a href="#3、修改权限-chmod" class="headerlink" title="3、修改权限 - chmod"></a>3、修改权限 - chmod</h4><h5 id="1、基本说明"><a href="#1、基本说明" class="headerlink" title="1、基本说明"></a>1、基本说明</h5><p>​            通过 chmod 指令，可以修改文件或者目录的权限</p>
<h5 id="2、第一种方式：-、-、-变更权限"><a href="#2、第一种方式：-、-、-变更权限" class="headerlink" title="2、第一种方式：+ 、-、= 变更权限"></a>2、第一种方式：+ 、-、= 变更权限</h5><p>​        u:所有者  g:所有组   o:其他人  a:所有人(u、g、o 的总和)</p>
<p>​        1) chmod   u=rwx,g=rx,o=x   文件目录名</p>
<p>​        2) chmod   o+w    文件目录名</p>
<p>​        3) chmod   a-x    文件目录名</p>
<p>​    案例演示</p>
<p>​    1)  给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113153609433.png" alt="image-20220113153609433" style="zoom:50%;">

<p>​    2） 给abc 文件的所有者除去执行的权限，增加组写的权限</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113153832943.png" alt="image-20220113153832943" style="zoom:50%;">

<p>​    3）给 abc 文件的所有用户添加读的权限</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113154018146.png" alt="image-20220113154018146" style="zoom:50%;">

<p>​        </p>
<h5 id="3、-第二种方式：通过数字变更权限"><a href="#3、-第二种方式：通过数字变更权限" class="headerlink" title="3、 第二种方式：通过数字变更权限"></a>3、 第二种方式：通过数字变更权限</h5><p>​            规则：<strong>r=4 w=2 x=1</strong> </p>
<p>​            rwx=4+2+1=7 chmod u=rwx,g=rx,o=x   文件目录名相当于  chmod 751  文件目录名</p>
<p>​            案例：</p>
<p>​            要求：将  /home/abc.txt 文件的权限修改成  rwxr-xr-x, 使用给数字的方式实现：</p>
<p>​            rwx = 4+2+1 = 7</p>
<p>​            r-x = 4+1=5</p>
<p>​            r-x = 4+1 =5</p>
<p>​            指令：<strong>chmod 755 /home/abc.txt</strong></p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113154756214.png" alt="image-20220113154756214" style="zoom:50%;">



<h4 id="4、修改文件所有者-chown"><a href="#4、修改文件所有者-chown" class="headerlink" title="4、修改文件所有者 - chown"></a>4、修改文件所有者 - chown</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​        chown  newowner  file                       改变文件的所有者</p>
<p>​        chown newowner:newgroup file      改变用户的所有者和所有组</p>
<p>​        <strong>-R   如果是目录 则使其下所有子文件或目录递归生效</strong></p>
<h5 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h5><p>​        1）请将 /home/kkk 目录下所有的文件和目录的所有者都修改成 tom</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113161856606.png" alt="image-20220113161856606" style="zoom:50%;">

<p>​        2）请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪) </p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113162314993.png" alt="image-20220113162314993" style="zoom:50%;">



<h3 id="三、Linux任务调度"><a href="#三、Linux任务调度" class="headerlink" title="三、Linux任务调度"></a>三、Linux任务调度</h3><h4 id="1、原理示意图"><a href="#1、原理示意图" class="headerlink" title="1、原理示意图"></a>1、原理示意图</h4><img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113165252639.png" alt="image-20220113165252639" style="zoom:50%;">

<h4 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h4><p>​    任务调度：是指系统在某个时间执行的特定的命令或程序。</p>
<p>​    任务调度分类：</p>
<p>​            1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p>
<p>​            2.个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。</p>
<h4 id="3、基本语法"><a href="#3、基本语法" class="headerlink" title="3、基本语法"></a>3、基本语法</h4><p>​        <strong>crontab [选项]</strong></p>
<p>​        常用选项：</p>
<p>​        <img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113165525877.png" alt="image-20220113165525877" style="zoom:50%;"></p>
<h4 id="4、快速入门"><a href="#4、快速入门" class="headerlink" title="4、快速入门"></a>4、快速入门</h4><p>​        任务要求</p>
<p>​        设置任务调度文件：/etc/crontab</p>
<p>​        设置个人任务调度。执行 crontab –e 命令。接着输入任务到调度文件</p>
<p>​        如：*/1 * * * * ls –l                  /etc/ &gt; /tmp/to.txt</p>
<p>​        意思说每小时的每分钟执行 ls –l /etc/ &gt; /tmp/to.txt 命令</p>
<p>​        1）进入到编辑模式</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113170955177.png" alt="image-20220113170955177" style="zoom:50%;">

<p>​        2）添加一下文件</p>
<p>​            <img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113171039121.png" alt="image-20220113171039121" style="zoom:50%;"></p>
<p>​        3）效果</p>
<p>​                是一分钟后在tmp目录下，就会多一个to.txt文件</p>
<p>​        4）占位符说明        </p>
<p>​        <img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113171308317.png" alt="image-20220113171308317" style="zoom:50%;">        </p>
<ul>
<li>特殊符号说明</li>
</ul>
<p>​            <img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113171400349.png" alt="image-20220113171400349" style="zoom:50%;"></p>
<ul>
<li><p>特定时间执行任务案例</p>
<img src="/2022/01/13/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E4%B8%89)/image-20220113171522858.png" alt="image-20220113171522858" style="zoom:50%;"></li>
</ul>
<h4 id="5、任务调度的应用实例"><a href="#5、任务调度的应用实例" class="headerlink" title="5、任务调度的应用实例"></a>5、任务调度的应用实例</h4><h5 id="1、案例1"><a href="#1、案例1" class="headerlink" title="1、案例1"></a>1、案例1</h5><p>每隔1分钟，就将当前的日期信息追加到/tmp/mydate文件中</p>
<p>​        1）先编写一个文件 /home/mytask1.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date &gt;&gt;/tmp/mydate</span><br></pre></td></tr></table></figure>

<p>​        2）给mytask1.sh一个可执行的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x mytask1.sh</span><br></pre></td></tr></table></figure>

<p>​        3）crontab -e</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/1 * * * * /home/mytask1.sh</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Zookeeper学习(一)</title>
    <url>/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="1、Zookeeper入门"><a href="#1、Zookeeper入门" class="headerlink" title="1、Zookeeper入门"></a>1、Zookeeper入门</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Zookeeper从设计模式角度来理解：是一个基于<strong>观察者模式设计</strong>的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p>
<h4 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h4><img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117154742344.png" alt="image-20220117154742344" style="zoom:50%;">

<p>1）Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。 </p>
<p>2）集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。 </p>
<p>3）全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 </p>
<p>4）更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。 </p>
<p>5）数据更新原子性，一次数据更新要么成功，要么失败。 </p>
<p>6）实时性，在一定时间范围内，Client能读到最新数据。</p>
<h4 id="1-3-数据结构"><a href="#1-3-数据结构" class="headerlink" title="1.3 数据结构"></a>1.3 数据结构</h4><p>​        ZooKeeper 数据模型的结构与 Unix 文件系统很类似，<strong>整体上可以看作是一棵树，每个节点称做一个 ZNode</strong>。每一个 ZNode 默认能够存储 1MB 的数据，<strong>每个 ZNode 都可以通过其路径唯一标识</strong>。</p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117160153014.png" alt="image-20220117160153014" style="zoom: 33%;">



<h4 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h4><p>​        提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下 线、软负载均衡等。</p>
<h5 id="1-4-1-统一命名服务"><a href="#1-4-1-统一命名服务" class="headerlink" title="1.4.1 统一命名服务"></a>1.4.1 统一命名服务</h5><p>​    在分布式环境下，经常需要对应用/服 务进行统一命名，便于识别。 例如：IP不容易记住，而域名容易记住。</p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117160804778.png" alt="image-20220117160804778" style="zoom:33%;">

<p>​    </p>
<h5 id="1-4-2-统一配置管理"><a href="#1-4-2-统一配置管理" class="headerlink" title="1.4.2 统一配置管理"></a>1.4.2 统一配置管理</h5><p>​    <strong>1）分布式环境下，配置文件同步非常常见</strong></p>
<p>​         （1）一般要求一个集群中，所有节点的配置信息是 一致的，比如 Kafka 集群。</p>
<p>​         （2）对配置文件修改后，希望能够快速同步到各个 节点上。</p>
<p>​    </p>
<p>​    <strong>2）配置管理可交由ZooKeeper实现</strong></p>
<p>​        （1）可将配置信息写入ZooKeeper上的一个Znode。</p>
<p>​        （2）各个客户端服务器监听这个Znode</p>
<p>​        （3）一 旦Znode中的数据被修改，ZooKeeper将通知各个客户端服务器</p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117162106703.png" alt="image-20220117162106703" style="zoom:50%;">

<h5 id="1-4-3-统一集群管理"><a href="#1-4-3-统一集群管理" class="headerlink" title="1.4.3 统一集群管理"></a>1.4.3 统一集群管理</h5><p>​    <strong>1）分布式环境中，实时掌握每个节点的状态是必要的</strong></p>
<p>​            （1）可根据节点实时状态做出一些调整</p>
<p>​    <strong>2）ZooKeeper可以实现实时监控节点状态变化</strong></p>
<p>​            （1）可将节点信息写入ZooKeeper上的一个ZNode</p>
<p>​            （2）监听这个ZNode可获取它的实时状态变化</p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117162714600.png" alt="image-20220117162714600" style="zoom:50%;">

<h5 id="1-4-4-服务器动态上下线"><a href="#1-4-4-服务器动态上下线" class="headerlink" title="1.4.4 服务器动态上下线"></a>1.4.4 服务器动态上下线</h5><p>​    <strong>客户端能实时洞察到服务器上下线的变化</strong></p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117162902235.png" alt="image-20220117162902235" style="zoom:33%;">



<h5 id="1-4-5-软负载均衡"><a href="#1-4-5-软负载均衡" class="headerlink" title="1.4.5 软负载均衡"></a>1.4.5 软负载均衡</h5><p>​          <strong>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</strong></p>
<img src="/2022/01/17/Zookeeper%E5%AD%A6%E4%B9%A0/image-20220117163049756.png" alt="image-20220117163049756" style="zoom:50%;">



<h3 id="2、Zookeeper安装教程"><a href="#2、Zookeeper安装教程" class="headerlink" title="2、Zookeeper安装教程"></a>2、Zookeeper安装教程</h3><p>​        1、在安装zk之前，虚拟机中首先需要安装jdk</p>
<p>​            （1）<strong>查看云端目前支持安装的jdk版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum search java|grep jdk</span><br></pre></td></tr></table></figure>

<p>​            （2）<strong>选择版本后，安装（执行以下<a href="https://www.linuxcool.com/">命令</a>会自动安装jdk相关依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#  yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<p>​            （3）<strong>安装完成，验证是否安装成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# java -version</span><br></pre></td></tr></table></figure>

<p>​            （4）<strong>通过搜索java文件，查找jdk默认安装目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# find / -name &#x27;java&#x27;</span><br></pre></td></tr></table></figure>

<p>​            </p>
<p>​        2、安装zk</p>
]]></content>
  </entry>
  <entry>
    <title>Linux实战篇（四）- 磁盘</title>
    <url>/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/</url>
    <content><![CDATA[<h3 id="一、Linux磁盘分区"><a href="#一、Linux磁盘分区" class="headerlink" title="一、Linux磁盘分区"></a>一、Linux磁盘分区</h3><h4 id="1、原理介绍"><a href="#1、原理介绍" class="headerlink" title="1、原理介绍"></a>1、原理介绍</h4><p>​    1) Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。</p>
<p>​    2) Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<h4 id="2、示意图"><a href="#2、示意图" class="headerlink" title="2、示意图"></a>2、示意图</h4><p>​    <img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114101732404.png" alt="image-20220114101732404" style="zoom:50%;"></p>
<h4 id="3、硬盘说明"><a href="#3、硬盘说明" class="headerlink" title="3、硬盘说明"></a>3、硬盘说明</h4><p>​    1) Linux 硬盘分 <strong>IDE 硬盘和 SCSI 硬盘</strong>，目前基本上是 <strong>SCSI 硬盘</strong></p>
<p>​    2) 对于 IDE 硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“</del>”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。</p>
<p>​    3) <strong>对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样。</strong></p>
<p>​    4) 使用 <strong>lsblk 指令</strong>查看当前系统的分区情况</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114101659455.png" alt="image-20220114101659455">



<h4 id="4、挂载的经典案例"><a href="#4、挂载的经典案例" class="headerlink" title="4、挂载的经典案例"></a>4、挂载的经典案例</h4><h5 id="1、需求说明"><a href="#1、需求说明" class="headerlink" title="1、需求说明"></a>1、需求说明</h5><pre><code> 1、需求是给我们的 Linux 系统增加一个新的硬盘，并且挂载到/home/newdisk
</code></pre>
<h5 id><a href="#" class="headerlink" title></a><img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114102620885.png" alt="image-20220114102620885" style="zoom: 50%;"></h5><h5 id="2、具体步骤"><a href="#2、具体步骤" class="headerlink" title="2、具体步骤"></a>2、具体步骤</h5><p>​    <strong>1）虚拟机增加硬盘步骤</strong></p>
<p>​         在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！</p>
<p>​        <img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114104221617.png" alt="image-20220114104221617" style="zoom:50%;"></p>
<p>​    <strong>2）虚拟机增加硬盘步骤 2</strong></p>
<p>​        分区命令   fdisk   /dev/sdb</p>
<p>​        开始对/sdb 分区</p>
<p>​            •      m  显示命令列表</p>
<p>​            •      p   显示磁盘分区 同 fdisk  –l</p>
<p>​            •      n  新增分区</p>
<p>​            •       d 删除分区</p>
<p>​            •      w  写入并退出</p>
<p>说明： 开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q。</p>
<p>​    <strong>3）虚拟机增加硬盘步骤 3</strong></p>
<p>​        格式化磁盘</p>
<p>​            分区命令:mkfs -t  ext4   /dev/sdb1</p>
<p>​            其中 ext4 是分区类型</p>
<p>​    <strong>4）虚拟机增加硬盘步骤 4</strong></p>
<p>挂载: 将一个分区与一个目录联系起来，</p>
<p>​    •  mount     设备名称 挂载目录</p>
<p>​    •  例如：  mount           /dev/sdb1 /newdisk</p>
<p>​    •  umount          设备名称  或者  挂载目录</p>
<p>​    •   例如：    umount /dev/sdb1 或 者  umount /newdisk</p>
<p>​    <strong>5)  虚拟机增加硬盘步骤 5</strong></p>
<p>​         永久挂载: 通过修改/etc/fstab 实现挂载添加完成后  执行 <strong>mount –a</strong> 即刻生效</p>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114110209700.png" alt="image-20220114110209700" style="zoom:50%;">

<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114110314088.png" alt="image-20220114110314088" style="zoom:50%;">



<h4 id="5、磁盘情况查询"><a href="#5、磁盘情况查询" class="headerlink" title="5、磁盘情况查询"></a>5、磁盘情况查询</h4><h5 id="1、查询系统整体磁盘使用情况"><a href="#1、查询系统整体磁盘使用情况" class="headerlink" title="1、查询系统整体磁盘使用情况"></a>1、查询系统整体磁盘使用情况</h5><p>​            基本语法：<strong>df -h</strong></p>
<p>​            应用实例</p>
<pre><code>           查询系统整体磁盘使用情况
</code></pre>
<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114111252847.png" alt="image-20220114111252847" style="zoom:50%;">

<h5 id="2、查询指定目录的磁盘占用情况"><a href="#2、查询指定目录的磁盘占用情况" class="headerlink" title="2、查询指定目录的磁盘占用情况"></a>2、查询指定目录的磁盘占用情况</h5><p>​        1）基本语法</p>
<p>​            du -h  /目录</p>
<p>​        查询指定目录的磁盘占用情况，默认为当前目录</p>
<p>​            -s 指定目录占用大小汇总</p>
<p>​            -h 带计量单位</p>
<p>​            -a 含文件</p>
<p>​            –max-depth=1  子目录深度</p>
<p>​            -c 列出明细的同时，增加汇总值</p>
<p>​        2）应用实例         </p>
<p>​            查询 /opt 目录的磁盘占用情况，深度为 1    </p>
<p>​    <img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114111737602.png" alt="image-20220114111737602" style="zoom: 50%;"></p>
<h5 id="3、磁盘情况-工作实用指令"><a href="#3、磁盘情况-工作实用指令" class="headerlink" title="3、磁盘情况-工作实用指令"></a>3、磁盘情况-工作实用指令</h5><p>​    1）统计/home文件夹下文件的个数        </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /home | grep &quot;^-&quot; |wc -l</span><br></pre></td></tr></table></figure>

<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114112125123.png" alt="image-20220114112125123" style="zoom:50%;">

<p>​    2）统计/home 文件夹下目录的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /home | grep &quot;^d&quot; |wc -l</span><br></pre></td></tr></table></figure>

<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114112310233.png" alt="image-20220114112310233" style="zoom:50%;">

<p>​    3）统计/home 文件夹下文件的个数，包括子文件夹里的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /home |grep &quot;^-&quot; |wc -l</span><br></pre></td></tr></table></figure>

<img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114112531939.png" alt="image-20220114112531939" style="zoom:50%;">

<p>​    4）以树状显示目录结构</p>
<p>​        <img src="/2022/01/14/Linux%E5%AE%9E%E6%88%98%E7%AF%87(%E5%9B%9B)/image-20220114112742085.png" alt="image-20220114112742085" style="zoom:50%;"></p>
]]></content>
  </entry>
  <entry>
    <title>TCP/IP协议一</title>
    <url>/2022/01/24/TCP-IP%E5%8D%8F%E8%AE%AE%E4%B8%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>好代码的特性</title>
    <url>/2022/01/16/%E5%A5%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="好代码的几大特性"><a href="#好代码的几大特性" class="headerlink" title="好代码的几大特性"></a>好代码的几大特性</h3><p>1.代码的正确性 – 对应项目的健壮和有用<br>2.代码的可读性 – 对应后续的维护和开发(可维护性)<br>3.代码的效率性 – 对应项目的使用效率<br>4.代码的可扩展性 –模块、类、函数功能划分清晰<br>5.平台的兼容性、网络的安全性等</p>
<h4 id="1、代码的正确性"><a href="#1、代码的正确性" class="headerlink" title="1、代码的正确性"></a>1、代码的正确性</h4><p>代码是否设计、结构合理以及充分满足需求等<br>代码是否实现了其功能<br>代码是否有对应的测试代码<br>代码是否有异常处理、日志记录、良好的健壮性</p>
<h4 id="2、代码的可读性"><a href="#2、代码的可读性" class="headerlink" title="2、代码的可读性"></a>2、代码的可读性</h4><p>模块、类、函数作用划分是否清晰<br>类名称、函数名称、变量名称是否一目了然<br>是否使用较好的抽象数据，便于可读和维护<br>代码呈现组织结构型，便于区分代码之间的相关有无、依赖有无。<br>代码简洁、高效、注释齐全、函数接口，输入输出，注释说明 清晰合理</p>
<h4 id="3、效率性"><a href="#3、效率性" class="headerlink" title="3、效率性"></a>3、效率性</h4><p>合适匹配的底层、数据库工具、编程语言、工程架构等。<br>优异的算法<br>代码的适用场景和此场景下代码最佳运行效率<br>底层偏向于c，c的高效性</p>
<h4 id="4、健壮性"><a href="#4、健壮性" class="headerlink" title="4、健壮性"></a>4、健壮性</h4><h5 id="1、健壮性的思想"><a href="#1、健壮性的思想" class="headerlink" title="1、健壮性的思想"></a>1、健壮性的思想</h5><p>（1）正常运行的代码，首要追求高效性</p>
<p>​          这个“高效性”如果从逻辑的角度来解释, 那么一方面是”高效”地对正确的数据执行正确的算法(方法/策略), 另一方面是”高效”地找出异常, 然后丢给异常处理代码去处理.</p>
<p>（2）处理异常的代码. 首要追求健壮性</p>
<p>​          就是程序必须能从异常中自我恢复. 由于代码多数时间跑的是”正常”逻辑, 少数情况下才不得不处理”异常”, 所以”异常”处理的代码中, 首要任务是健壮, 跑不死, 而高效性则是次要的.</p>
<h5 id="2、健壮性运用"><a href="#2、健壮性运用" class="headerlink" title="2、健壮性运用"></a>2、健壮性运用</h5><p>​    <strong>（1）清理代码，去掉冗余代码</strong></p>
<p>​             很多时候，我们的代码都是迭代开发的。往往会罗列一些无用的函数，引入一些无用的类库。这些内容貌似无意义，但却是代码中的隐患。可能在后续的类库更新或者函数变更中爆炸。所以，代码要保持清理，对于无用的引用和定义，要加以清除。</p>
<p>​    <strong>（2）保证函数返回值一致</strong></p>
<p>​            之前很多时候写函数往往很随性，返回值类型可以能代表函数执行成功或者失败的Bool型，也会有代表实际结果的Str或者Int等类型。<strong>这样的函数在外部调用时痛苦非常，因为在函数调用后处理时，处理不当就会出现typeError，所以在函数编写前，要思考后本函数的作用，同时确定返回值类型，在函数的所有涉及到返回结果时，给予一致类型的返回值，方便外部调用。</strong></p>
<p>​    <strong>（3）必要情况下的try…Catch处理</strong></p>
<p>​             Try…Catch…处理异常是各种语言都有的模式。但到底在何处使用却有讲究。<strong>在没有抛异常的语句使用try语句，会降低性能，带来代码冗余，而在需要处理的语句未加异常处理，则会带来运行崩溃的可能</strong>。所以，要深刻的了解代码的语句，是否存在抛异常的可能，对可能抛异常的语言要加以处理。</p>
]]></content>
  </entry>
  <entry>
    <title>如何写高质量代码</title>
    <url>/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h2><p>（1）写什么样的注释</p>
<p>​    写有意义的注释，而不是废话的、没有价值的注释。注释的目的是帮助读代码的人了解作者在写代码时的思想。</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111221614079.png" alt="image-20220111221614079"></p>
<p>（2）为代码中的瑕疵写注释</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111222032881.png" alt="image-20220111222032881"></p>
<p><strong>（3）注释编写的步骤：</strong></p>
<p>​        1）不管你心里再想什么，先把它记录下来</p>
<p>​        2）读一下这段注释，看看它有什么改进的地方</p>
<p>​        3）不断改进</p>
<p><strong>（4）什么地方不需要注释</strong></p>
<p>​        1）能从代码本身中快速推断的事实</p>
<p>​        2）用来装饰垃圾代码（比如拗口的方法名），实际上应该把名称修改好</p>
<p><strong>（5）记录你的想法</strong></p>
<p>​        1）为什么代码写成这样而不是另外一个样子的内在理由（<strong>指导性批注</strong>）</p>
<p>​        2）代码中的不足，使用像TODO这样的标注</p>
<p>​        3）常量背后的意义，为什么是这个值？</p>
<p><strong>（6）在读者的立场思考</strong></p>
<p>​        1）预料到代码中哪些部分会让读者产生疑惑，给它加上注释</p>
<p>​        2）为小白意料之外的行为加注释</p>
<p>​        3）在文件、类级别上使用“全局观”注释来解释所有的部分是如何一起工作的</p>
<p>​        4）用注释总结代码块，让读者不会迷茫在细节里</p>
<p>总结：<strong>言简意赅的注释，通过简单的注释体现代码的核心、深层思想</strong></p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111222502761.png" alt="image-20220111222502761"></p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111222544528.png" alt="image-20220111222544528"></p>
<h2 id="二、简化流程让代码易读"><a href="#二、简化流程让代码易读" class="headerlink" title="二、简化流程让代码易读"></a>二、<strong>简化流程让代码易读</strong></h2><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111222640225.png" alt="image-20220111222640225"></p>
<h2 id="三、拆分又臭又长的表达式"><a href="#三、拆分又臭又长的表达式" class="headerlink" title="三、拆分又臭又长的表达式"></a>三、<strong>拆分又臭又长的表达式</strong></h2><p>（1）尽量不要在if语句里面写表达式，这样的代码可读性比较差，最好将表达式提出来赋值给一个中间变量，提高代码可读性</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111222805807.png" alt="image-20220111222805807"></p>
<p>（2）反向思考，问题更加简单</p>
<pre><code>      以下代码是判断传入的集合是否和指定的集合有交集， 如果使用正向的思维，需要判断和比较的内容就很多。如果使用反向的思维，则只需要两行代码就可以解决问题，解决了又臭又长的代码
</code></pre>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111223048465.png" alt="image-20220111223048465"></p>
<p>总结：</p>
<p>引入“解释变量”代替较长的子表达式，有三个好处：</p>
<p>1、它把巨大的表达式拆分成一个小段</p>
<p>2、通过简单的名字来描述一个子表达式，让代码文档化</p>
<p>3、它帮助读者识别代码中重要的概念</p>
<h2 id="四、变量与可读性"><a href="#四、变量与可读性" class="headerlink" title="四、变量与可读性"></a>四、变量与可读性</h2><p>这一行代码就是多余的</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111223411878.png" alt="image-20220111223411878"></p>
<p>改为：</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111223431529.png" alt="image-20220111223431529"></p>
<p>总结：</p>
<p>1）减少变量，通过立刻处理结果来消除中间变量</p>
<p>2）<strong>减少变量作用域，作用域越小越好</strong></p>
<p>3）变量只写一次最好，只设置一次的变量会让代码变得更加容易理解。</p>
<h2 id="五、抽离无关代码"><a href="#五、抽离无关代码" class="headerlink" title="五、抽离无关代码"></a>五、<strong>抽离无关代码</strong></h2><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111223523193.png" alt="image-20220111223523193"></p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220111223532507.png" alt="image-20220111223532507"></p>
<p><strong>尽量少用非逻辑，使用正逻辑，便于理解</strong></p>
<h2 id="六、好的方法"><a href="#六、好的方法" class="headerlink" title="六、好的方法"></a>六、好的方法</h2><h4 id="1、封装判断"><a href="#1、封装判断" class="headerlink" title="1、封装判断"></a>1、封装判断</h4><p>​    好的方法是清晰易懂的，如果把解释条件意图作为函数抽离出来，用函数名把判断条件的语义显性化地表达出来，就能立即提升代码的可读性和可理解性</p>
<p>原始代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(customer.getCrmUserId().equals(NIL_VALUE)</span><br><span class="line">              &amp;&amp; customer.getCustomerGroup() != CustomerGroup. CANCEL_ GROUP)</span><br><span class="line">        &#123;</span><br><span class="line">           privateSea.pickUp(customer);     </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，if后面的判断比较恶心，原因是缺少封装和合理的命名，可以使用封装判断改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(canPickUpToPrivateSea())</span><br><span class="line">        &#123;</span><br><span class="line">            privateSea.pickUp(customer);          </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPickUpToPrivateSea</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(StringUtil.isBlank(<span class="keyword">this</span>.getCrmUserId()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.getCustomerGroup() == CustomerGroup.CANCEL_GROUP)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>重构后的代码的可读性自然提升不少。</p>
<h4 id="2、方法参数"><a href="#2、方法参数" class="headerlink" title="2、方法参数"></a>2、方法参数</h4><p>总体上说，参数越少越容易理解，方法也越容易测试和使用，如果方法需要3个以上参数，就说明其中一些参数应该封装为类。</p>
<h4 id="3、短小的方法"><a href="#3、短小的方法" class="headerlink" title="3、短小的方法"></a>3、短小的方法</h4><p>有时保持代码的逻辑不变，只是把长方法改为多个短方法，代码的可读性就能提高很多，。超长方法是典型的代码“坏味道”，对超长方法的结构化分解是提升代码可读性最有效的方式之一。</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122224734862.png" alt="image-20220122224734862"></p>
<h4 id="4、职责单一"><a href="#4、职责单一" class="headerlink" title="4、职责单一"></a>4、职责单一</h4><p><strong>一个方法只做一件事情，也就是方法级别的单一职责原则（SRP）</strong></p>
<p>遵循SRP不仅可以提升代码的可读性，还能提升代码的可复用性。因为职责越单一，功能越内聚，就越有可能被复用，这和代码的行数没有直接的关联性，但是有间接的关联性。</p>
<p>​    长方法意味着肯定需要拆分，需要用多个子函数的组合进行更好的表达。然而短小的函数并不一定就意味着不需要拆分，只要不满足SRP,值得进一步分解。哪怕分解后的子函数只有一行代码，只要有助于业务语义显性化的表达，就是值得到。</p>
<h4 id="5、精简辅助代码"><a href="#5、精简辅助代码" class="headerlink" title="5、精简辅助代码"></a>5、精简辅助代码</h4><p>​    辅助代码就是程序运行中不可少的代码，但又不是处理业务逻辑的核心代码，比如判空，打印日志，鉴权，降级和缓存检查等。这些代码一般会在多个方法中重复，减少辅助代码可以让代码显得更加整洁，易于维护。</p>
<p>​    </p>
<h4 id="6、优化判空"><a href="#6、优化判空" class="headerlink" title="6、优化判空"></a>6、优化判空</h4><p>​    判空是为让代码具有一定的健壮性，只是这样的判空代码多了，会干扰阅读代码的流畅性。</p>
<p>原始代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String isocode = user.getAddress(). getCountry(). getIsocode(). toUpperCase();</span><br></pre></td></tr></table></figure>

<p>因为任何访问对象方法或属性的调用都可能会导致NPE,因此如果要确保不触发异常，就得在访问每一个值之前对其进行明确的检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (user != null) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    if (address != null) &#123;</span><br><span class="line">        Country country = address.getCountry();</span><br><span class="line">        if (country != null) &#123;</span><br><span class="line">            String isocode = country.getIsocode();</span><br><span class="line">            if (isocode != null) &#123;</span><br><span class="line">                isocode = isocode.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java8 - Optional类可以用Optional类代替冗长的null检查：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String isocode = Optional.ofNullable(user)</span><br><span class="line">  .flatMap(User::getAddress)</span><br><span class="line">  .flatMap(Address::getCountry)</span><br><span class="line">  .map(Country::getIsocode)</span><br><span class="line">  .orElse(&quot;default&quot;);</span><br></pre></td></tr></table></figure>

<p>这种写法就显得很简洁，简洁是一种美。</p>
<h4 id="7、组合函数模式"><a href="#7、组合函数模式" class="headerlink" title="7、组合函数模式"></a>7、组合函数模式</h4><p>​        1、是一个非常容易理解上手、实用、对代码可读性和可维护性起到很有效的编程原则。</p>
<p>​        2、组合的方式是在代码重构中使用比较多，在重构代码之前需要读懂代码做了哪几件事，再进行重构。组合函数要求所有的公有方法的读起来像一系列执行步骤的概要，而这些步骤的真正实现细节是在私有方法里面的。</p>
<p>​        3、<strong>组合函数要求将一个大函数拆成多个子函数的组合。</strong></p>
<h4 id="8、SLAP-抽象层次一致性"><a href="#8、SLAP-抽象层次一致性" class="headerlink" title="8、SLAP - 抽象层次一致性"></a>8、SLAP - 抽象层次一致性</h4><p>​       抽象层次一致性要求方法体的内容必须在同一个抽象层次上。如果高层次抽象和底层细节杂糅在一起，就会显得很乱，难以理解、</p>
<h4 id="9、switch语句"><a href="#9、switch语句" class="headerlink" title="9、switch语句"></a>9、switch语句</h4><h4 id="10、方法参数"><a href="#10、方法参数" class="headerlink" title="10、方法参数"></a>10、方法参数</h4><p>​        从复杂度的角度看，方法的参数个数越少方法的复杂度相对越低</p>
<img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122225824667.png" alt="image-20220122225824667" style="zoom:50%;">

<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122230346196.png" alt="image-20220122230346196"></p>
<h4 id="11、三元函数"><a href="#11、三元函数" class="headerlink" title="11、三元函数"></a>11、三元函数</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122232033145.png" alt="image-20220122232033145"></p>
<h4 id="12、参数对象"><a href="#12、参数对象" class="headerlink" title="12、参数对象"></a>12、参数对象</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122232206155.png" alt="image-20220122232206155"></p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122232250317.png" alt="image-20220122232250317"></p>
<h4 id="13、动词和关键字"><a href="#13、动词和关键字" class="headerlink" title="13、动词和关键字"></a>13、动词和关键字</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122232550562.png" alt="image-20220122232550562"></p>
<h4 id="14、抽离try-catch代码块"><a href="#14、抽离try-catch代码块" class="headerlink" title="14、抽离try/catch代码块"></a>14、抽离try/catch代码块</h4><p>原始代码：</p>
<img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122234455197.png" alt="image-20220122234455197" style="zoom:33%;">

<p>优化： </p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122234610346.png" alt="image-20220122234610346"></p>
<h4 id="15、错误处理就是一件事"><a href="#15、错误处理就是一件事" class="headerlink" title="15、错误处理就是一件事"></a>15、错误处理就是一件事</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122235916347.png" alt="image-20220122235916347"></p>
<h4 id="16、别重复自己"><a href="#16、别重复自己" class="headerlink" title="16、别重复自己"></a>16、别重复自己</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220123000424261.png" alt="image-20220123000424261"></p>
<h2 id="七、命名的艺术"><a href="#七、命名的艺术" class="headerlink" title="七、命名的艺术"></a>七、命名的艺术</h2><h4 id="1、避免误导"><a href="#1、避免误导" class="headerlink" title="1、避免误导"></a>1、避免误导</h4><p>​        以数字系列命名（a1,a2…..aN）是依义命名的对立面。这样的名称纯属误导，完全没有提供正确信息，没有提供导向作者意图的线索</p>
<h4 id="2、避免废话"><a href="#2、避免废话" class="headerlink" title="2、避免废话"></a>2、避免废话</h4><p>​        废话是另一种意义的区分。假设你有一个Product类。如果还有一个ProductInfo或ProductData类，那他们的名称虽然不同，但是表达的含义没什么区别。Info和Data就像a，an和the一样是意义含混的废话。</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/93b8a342-776e-429e-9e33-5133c3f6b60d.png" alt="img"></p>
<h4 id="3、使用读得出来的名称"><a href="#3、使用读得出来的名称" class="headerlink" title="3、使用读得出来的名称"></a>3、使用读得出来的名称</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122213438210.png" alt="image-20220122213438210"></p>
<h4 id="4、使用可搜索的名称"><a href="#4、使用可搜索的名称" class="headerlink" title="4、使用可搜索的名称"></a>4、使用可搜索的名称</h4><p>​    1、单字母名称和数字常量有一个问题，就是很难在一大篇文字中找到。</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122214543210.png" alt="image-20220122214543210"></p>
<h4 id="5、类名"><a href="#5、类名" class="headerlink" title="5、类名"></a>5、类名</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122221757197.png" alt="image-20220122221757197"></p>
<h4 id="6、方法名"><a href="#6、方法名" class="headerlink" title="6、方法名"></a>6、方法名<img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220122222043810.png" alt="image-20220122222043810"></h4><h2 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h2><h4 id="1、使用异常而非返回码"><a href="#1、使用异常而非返回码" class="headerlink" title="1、使用异常而非返回码"></a>1、使用异常而非返回码</h4><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124221504891.png" alt="image-20220124221504891" style="zoom:50%;">

<p>以上代码搞乱了调用者代码，调用者必须在调用之后即刻检查错误。所以遇到错误时，最好抛出一个异常，调用代码很整洁，其逻辑不会被错误处理搞乱。</p>
<img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124221957451.png" alt="image-20220124221957451" style="zoom:50%;">

<h4 id="2、先写Try-Catch-Finally语句"><a href="#2、先写Try-Catch-Finally语句" class="headerlink" title="2、先写Try-Catch-Finally语句"></a>2、先写Try-Catch-Finally语句</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124222628418.png" alt="image-20220124222628418"></p>
<h4 id="3、别返回null值"><a href="#3、别返回null值" class="headerlink" title="3、别返回null值"></a>3、别返回null值</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124230459576.png" alt="image-20220124230459576"></p>
<p>这样就可以减少判空的代码，使得代码更加整洁优美</p>
<h4 id="4、别传null值"><a href="#4、别传null值" class="headerlink" title="4、别传null值"></a>4、别传null值</h4><p>​    在方法中返回null值是糟糕的做法，但是将null值传递给其他方法就更加糟糕 。除非API要求你传递null值，否则就要尽可能避免传递null值。</p>
<p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124231139721.png" alt="image-20220124231139721"></p>
<h4 id="九、单元测试"><a href="#九、单元测试" class="headerlink" title="九、单元测试"></a>九、单元测试</h4><h4 id="1、保持测试整洁"><a href="#1、保持测试整洁" class="headerlink" title="1、保持测试整洁"></a>1、保持测试整洁</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124233640821.png" alt="image-20220124233640821"></p>
<h4 id="2、测试带来一切好处"><a href="#2、测试带来一切好处" class="headerlink" title="2、测试带来一切好处"></a>2、测试带来一切好处</h4><p><img src="/2022/01/11/%E5%A6%82%E4%BD%95%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/image-20220124234059006.png" alt="image-20220124234059006"></p>
]]></content>
  </entry>
  <entry>
    <title>常用工具及常用解决方案</title>
    <url>/2022/01/21/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="1、集合判空方法"><a href="#1、集合判空方法" class="headerlink" title="1、集合判空方法"></a>1、集合判空方法</h3><p> 使用org.apache.commons.collections4.CollectionUtils包下的**CollectionUtils.isNotEmpty(equipmentInfoList)**的方式判空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"></span><br><span class="line">List&lt;EquipmentInfo&gt; equipmentInfoList = equipmentInfoService.list(<span class="keyword">new</span> QueryWrapper&lt;EquipmentInfo&gt;().in(<span class="string">&quot;id&quot;</span>, params));</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isNotEmpty(equipmentInfoList))&#123;</span><br><span class="line">        <span class="keyword">for</span> (EquipmentInfo equipmentInfo : equipmentInfoList) &#123;</span><br><span class="line">            Integer type = equipmentInfo.getType();</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="keyword">null</span>)&#123;</span><br><span class="line">                String equipmentType = DictBizCache.getValue(<span class="string">&quot;safe_equipment_type&quot;</span>, type);</span><br><span class="line">                equipmentInfo.setEquipmentType(equipmentType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：</p>
<p><strong>CollectionUtils.isNotEmpty(equipmentInfoList)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean isEmpty(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">        return coll == null || coll.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isNotEmpty(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">        return !isEmpty(coll);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean isEmpty(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">        return coll == null || coll.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、关于后端返回Long类型的数据到前端精度缺失的解决方法"><a href="#2、关于后端返回Long类型的数据到前端精度缺失的解决方法" class="headerlink" title="2、关于后端返回Long类型的数据到前端精度缺失的解决方法"></a>2、关于后端返回Long类型的数据到前端精度缺失的解决方法</h3><p> <strong>找到对应的实体类，在Long类型的属性上使用注解</strong></p>
<p><strong>@JsonSerialize(using = ToStringSerializer.class)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line">import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line"></span><br><span class="line">@JsonSerialize(using = ToStringSerializer.class)</span><br><span class="line">private Long projectId;</span><br></pre></td></tr></table></figure>

<p>这样返回到前端的数据就是一个字符串类型，不会出现精度缺失的问题。</p>
<h3 id="3、java8新特性-时间处理"><a href="#3、java8新特性-时间处理" class="headerlink" title="3、java8新特性 - 时间处理"></a>3、java8新特性 - 时间处理</h3><p> 1）获取日期</p>
<p>​    <strong>LocalDate</strong></p>
<p> 2）获取时间</p>
<p>​    <strong>LocalTime</strong></p>
<p> 3）获取日期时间</p>
<p>​    <strong>LocalDateTime</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取当前日期和当前日期加3天日期</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       LocalDate now = LocalDate.now();</span><br><span class="line">       LocalDate localDate1 = now.plusDays(<span class="number">1</span>);</span><br><span class="line">       LocalDate localDate2 = now.plusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(now);</span><br><span class="line">       System.out.println(localDate1);</span><br><span class="line">       System.out.println(localDate2);</span><br><span class="line">       System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">       LocalDateTime now1 = LocalDateTime.now();</span><br><span class="line">       System.out.println(now1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取最大时间和最小时间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       LocalTime min = LocalTime.MIN;</span><br><span class="line">       LocalTime max = LocalTime.MAX;</span><br><span class="line">       System.out.println(min); <span class="comment">// 00:00</span></span><br><span class="line">       System.out.println(max); <span class="comment">// 23:59:59.999999999</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 拼接日期和时间,时间格式化</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       LocalDateTime start = LocalDateTime.of(now, min);</span><br><span class="line">       LocalDateTime end = LocalDateTime.of(localDate2, max);</span><br><span class="line">       String startFormat = start.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">       String endFormat = end.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">       System.out.println(startFormat); <span class="comment">// 2021-12-02 00:00:00</span></span><br><span class="line">       System.out.println(endFormat); <span class="comment">// 2021-12-04 23:59:59</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、mybatisPlus中常用方法"><a href="#4、mybatisPlus中常用方法" class="headerlink" title="4、mybatisPlus中常用方法"></a>4、mybatisPlus中常用方法</h3><p>1）通过条件查询一个表中多条数据，使用list方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询列表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> 	com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2）批量保存多条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.saveBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="5、Objects-equals-Objects比较两个值是否相等"><a href="#5、Objects-equals-Objects比较两个值是否相等" class="headerlink" title="5、Objects.equals(Objects比较两个值是否相等)"></a>5、Objects.equals(Objects比较两个值是否相等)</h3><p><strong>尤其是包装类型的数据使用这种比较的方法比较好</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Objects.equals(CommonConstant.IS_COMPLATE,isComplate))&#123;</span><br><span class="line">			log.info(&quot;当前节点已完成！&quot;);</span><br><span class="line">			return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6、StringUtils-Spring工具类"><a href="#6、StringUtils-Spring工具类" class="headerlink" title="6、StringUtils(Spring工具类)"></a>6、StringUtils(Spring工具类)</h3><p>coll：需要处理的集合</p>
<p>delim：表示分隔符</p>
<p>该方法将集合类型的数据转为String字符串</p>
<p><strong>1）将List<Object>集合转为String字符串并用“,”分隔开</Object></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String collectionToCommaDelimitedString(@Nullable Collection&lt;?&gt; coll) &#123;</span><br><span class="line">        return collectionToDelimitedString(coll, &quot;,&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）字符串之间添加特殊分隔符</strong></p>
<p>StringUtils.collectionToDelimitedString(@Nullable Collection&lt;?&gt; coll, String delim);</p>
<p>3）演示代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        String s = StringUtils.collectionToCommaDelimitedString(list);</span><br><span class="line">        log.info(<span class="string">&quot;----&gt;&#123;&#125;&quot;</span>,s); <span class="comment">// ---&gt;111,222,333,444</span></span><br><span class="line"></span><br><span class="line">        String s1 = StringUtils.collectionToDelimitedString(list, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;----&gt;&#123;&#125;&quot;</span>,s1); <span class="comment">// ----&gt;111;222;333;444</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4）统计一个子字符串在字符串出现的次数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计一个子字符串在字符串出现的次数</span></span><br><span class="line"><span class="keyword">int</span> i = StringUtils.countOccurrencesOf(<span class="string">&quot;erowoiueoiur&quot;</span>, <span class="string">&quot;oiur&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;统计一个子字符串在字符串出现的次数:&#123;&#125;&quot;</span>,i); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = StringUtils.countOccurrencesOf(<span class="string">&quot;erowoiueoiur&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;统计一个子字符串在字符串出现的次数:&#123;&#125;&quot;</span>,i1); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s2 = StringUtils.countOccurrencesOf(<span class="string">&quot;s&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">log.info(<span class="string">&quot;统计一个子字符串在字符串出现的次数:&#123;&#125;&quot;</span>,s2); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s3 = StringUtils.countOccurrencesOf(<span class="keyword">null</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;统计一个子字符串在字符串出现的次数:&#123;&#125;&quot;</span>,s3); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h3 id="7、JSON-alibaba-常用方法"><a href="#7、JSON-alibaba-常用方法" class="headerlink" title="7、JSON(alibaba)常用方法"></a>7、JSON(alibaba)常用方法</h3><p><strong>1）将实体类转为JSON字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">String cartItemJson = JSON.toJSONString(cartItem);</span><br></pre></td></tr></table></figure>

<p><strong>2）将JSON字符串转为实体类(使用较多)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CartItem cartItem = JSON.parseObject(res, CartItem.class);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>设计原理</title>
    <url>/2022/01/21/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="1、设计模式的目的"><a href="#1、设计模式的目的" class="headerlink" title="1、设计模式的目的"></a>1、设计模式的目的</h3><p>​    编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重 用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好</p>
<p>​    1) <strong>代码重用性</strong> (即：相同功能的代码，不用多次编写) </p>
<p>​    2) <strong>可读性</strong> (即：编程规范性, 便于其他程序员的阅读和理解) </p>
<p>​    3) <strong>可扩展性</strong> (即：当需要增加新的功能时，非常的方便，称为可维护) </p>
<p>​    4) <strong>可靠性</strong> (即：当我们增加新的功能后，对原来的功能没有影响) </p>
<p>​    5) 使程序呈现<strong>高内聚，低耦合</strong>的特性</p>
<h3 id="2、设计模式七大原则"><a href="#2、设计模式七大原则" class="headerlink" title="2、设计模式七大原则"></a>2、设计模式七大原则</h3><p>​    设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模 式的基础(即：<strong>设计模式为什么这样设计的依据</strong>)</p>
<p>​    设计模式常用的七大原则有: </p>
<p>​        1) 单一职责原则 </p>
<p>​        2) 接口隔离原则 </p>
<p>​        3) 依赖倒转(倒置)原则 </p>
<p>​        4) 里氏替换原则 </p>
<p>​        5) 开闭原则 </p>
<p>​        6) 迪米特法则 </p>
<p>​        7) 合成复用原则</p>
<h4 id="2-1-单一职责原则"><a href="#2-1-单一职责原则" class="headerlink" title="2.1 单一职责原则"></a>2.1 单一职责原则</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​       对类来说的，即<strong>一个类应该只负责一项职责</strong>。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2</p>
<h5 id="2、单一职责原则注意事项和细节"><a href="#2、单一职责原则注意事项和细节" class="headerlink" title="2、单一职责原则注意事项和细节"></a>2、单一职责原则注意事项和细节</h5><p>​    1) 降低类的复杂度，一个类只负责一项职责。 </p>
<p>​    2) 提高类的可读性，可维护性 </p>
<p>​    3) 降低变更引起的风险 </p>
<p>​    4) 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</p>
<h4 id="2-2-接口隔离原则"><a href="#2-2-接口隔离原则" class="headerlink" title="2.2 接口隔离原则"></a>2.2 接口隔离原则</h4><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​        客户端不应该依赖它不需要的接口，<strong>即一个类对另一个类的依赖 应该建立在最小的接口上</strong></p>
<img src="/2022/01/21/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20220121100013646.png" alt="image-20220121100013646" style="zoom: 50%;">

<p>​        分析：</p>
<p>​        1）类A通过接口Interface1依赖类B，类C通过 接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口， 那么类B和类D必须去实现他们不需要的方 法。</p>
<p>​        2）按隔离原则应当这样处理</p>
<p>​            将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖 关系。也就是采用接口隔离原则</p>
<h5 id="2、接口隔离原则"><a href="#2、接口隔离原则" class="headerlink" title="2、接口隔离原则"></a>2、接口隔离原则</h5><p>​     应传统方法的问题和使用接口隔离原则改进</p>
<p>​    1）类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不 需要的方法</p>
<p>​    2）将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</p>
<p>​    3）接口Interface1中出现的方法，根据实际情况拆分为三个接口</p>
<img src="/2022/01/21/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20220121100823250.png" alt="image-20220121100823250" style="zoom: 67%;">



<h4 id="2-3-依赖倒转原则（DIP）"><a href="#2-3-依赖倒转原则（DIP）" class="headerlink" title="2.3 依赖倒转原则（DIP）"></a>2.3 依赖倒转原则（DIP）</h4><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​    1)  高层模块不应该依赖低层模块，二者都应该依赖其抽象 </p>
<p>​    2)  抽象不应该依赖细节，细节应该依赖抽象</p>
<p>​    3)  依赖倒转(倒置)的中心思想是面向接口编程</p>
<p>​    4)  依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。<strong>以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</strong></p>
<p>​    5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的 任务交给他们的实现类去完成</p>
<h5 id="2、依赖倒转原则注意事项和细节"><a href="#2、依赖倒转原则注意事项和细节" class="headerlink" title="2、依赖倒转原则注意事项和细节"></a>2、依赖倒转原则注意事项和细节</h5><p>​        1) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</p>
<p>​        2) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化 </p>
<p>​        3) 继承时遵循里氏替换原则</p>
<h4 id="2-4-里氏替换原则"><a href="#2-4-里氏替换原则" class="headerlink" title="2.4 里氏替换原则"></a>2.4 里氏替换原则</h4><h5 id="1、基本介绍-3"><a href="#1、基本介绍-3" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​        里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过<strong>聚合，组合，依赖</strong> 来解决问题。</p>
<p>​    2、以下程序引出的问题和思考</p>
<p>​    <img src="/2022/01/21/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20220121102504324.png" alt="image-20220121102504324"></p>
<p>​    解决方法：</p>
<p>​        1) 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候</p>
<p>​        2）通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉， 采用依赖，聚合，组合等关系代替</p>
<h4 id="2-5-开闭原则"><a href="#2-5-开闭原则" class="headerlink" title="2.5 开闭原则"></a>2.5 开闭原则</h4><h5 id="1、基本介绍-4"><a href="#1、基本介绍-4" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​    1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 </p>
<p>​    2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节 </p>
<p>​    3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已 有的代码来实现变化</p>
<p>​    4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</p>
<h4 id="2-6-迪米特法则"><a href="#2-6-迪米特法则" class="headerlink" title="2.6 迪米特法则"></a>2.6 迪米特法则</h4><h5 id="1、基本介绍-5"><a href="#1、基本介绍-5" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>​        1) 一个对象应该对其他对象保持最少的了解 </p>
<p>​        2) 类与类关系越密切，耦合度越大 </p>
<p>​        3) 迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即<strong>一个类对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息 </p>
<p>​        4) 迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></p>
<h5 id><a href="#" class="headerlink" title></a></h5><h5 id="2、迪米特法则注意事项和细节"><a href="#2、迪米特法则注意事项和细节" class="headerlink" title="2、迪米特法则注意事项和细节"></a>2、迪米特法则注意事项和细节</h5><p>​        1) 迪米特法则的核心是降低类之间的耦合 </p>
<p>​        2) 但是注意：由于每个类都减少了不必要的依赖，因此<strong>迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</strong></p>
<h4 id="2-7-合成复用原则"><a href="#2-7-合成复用原则" class="headerlink" title="2.7 合成复用原则"></a>2.7 合成复用原则</h4><p>​    原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h3 id="3、设计原则核心思想"><a href="#3、设计原则核心思想" class="headerlink" title="3、设计原则核心思想"></a>3、设计原则核心思想</h3><p>​    1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代 码混在一起。 </p>
<p>​    2) 针对接口编程，而不是针对实现编程。 </p>
<p>​    3) 为了交互对象之间的松耦合设计而努力</p>
]]></content>
  </entry>
  <entry>
    <title>java8实战一</title>
    <url>/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/</url>
    <content><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h3 id="1、通过行为参数化传递代码"><a href="#1、通过行为参数化传递代码" class="headerlink" title="1、通过行为参数化传递代码"></a>1、通过行为参数化传递代码</h3><p>1、java8对于程序员的主要好处在于它提供了更多的编程工具和概念，能以更快，更重要的是能以更为简洁、更易于维护的方式解决新的或现有的编程问题。</p>
<p>2、函数式编程思想，更适应新的计算机体系结构</p>
<p>3、什么是通过行为参数化传递代码？</p>
<p>​    1）<strong>行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。</strong></p>
<p>​    2）让方法接受多种行为（或战略）作为参数，并在内部使用，来完成不同的行为。</p>
<p>4、处理思路：</p>
<p>​        需求：用户需要筛选出重量大于150克，后来用户有需要筛选出颜色是绿色的苹果。</p>
<p>​    1）<strong>原始思维</strong>：处理筛选的问题，<strong>是在方法中添加参数</strong>，这种方法只能解决一时的问题，当外部的条件发生改变，方法则也需要跟着变化。</p>
<p>​    一种把所有属性结合起来的笨拙方法：<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124141916000.png" alt="image-20220124141916000"></p>
<p>​    2）<strong>行为参数化</strong></p>
<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124142306136.png" alt="image-20220124142306136" style="zoom:50%;">

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124142403874.png" alt="image-20220124142403874" style="zoom:50%;"><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124142549910.png" alt="image-20220124142549910"></p>
<p>2）以上这种方式的缺点是对付太啰嗦，过程较为复杂</p>
<h4 id="2、使用Lambda表达式"><a href="#2、使用Lambda表达式" class="headerlink" title="2、使用Lambda表达式"></a>2、使用Lambda表达式</h4><h4 id="1）将List类型抽象化"><a href="#1）将List类型抽象化" class="headerlink" title="1）将List类型抽象化"></a>1）将List类型抽象化<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124144541163.png" alt="image-20220124144541163"></h4><p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124144618279.png" alt="image-20220124144618279"></p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124145218793.png" alt="image-20220124145218793"></p>
<h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h3><h4 id="1）Lambda表达式的优点"><a href="#1）Lambda表达式的优点" class="headerlink" title="1）Lambda表达式的优点"></a>1）Lambda表达式的优点</h4><p>​        <strong>使用Lambda表达式可以写出更加简洁、更加灵活的代码</strong></p>
<p>2）Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表，函数主题，返回类型，可能还有一个可以抛出的异常列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匿名类的方式编写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lambda表达式的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Comparator&lt;Apple&gt; byWeightV1 = </span><br><span class="line">        (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124150857992.png" alt="image-20220124150857992"></p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124151014950.png" alt="image-20220124151014950"></p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124151218850.png" alt="image-20220124151218850"></p>
<h4 id="2）Lambda表达式语法"><a href="#2）Lambda表达式语法" class="headerlink" title="2）Lambda表达式语法"></a>2）Lambda表达式语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters)-&gt; expression</span><br></pre></td></tr></table></figure>

<p>​        或（请注意语句的花括号）    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters)-&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3）使用案例"><a href="#3）使用案例" class="headerlink" title="3）使用案例"></a>3）使用案例</h4><p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124151615360.png" alt="image-20220124151615360"></p>
<h4 id="4）函数式接口"><a href="#4）函数式接口" class="headerlink" title="4）函数式接口"></a>4）函数式接口</h4><p>​    函数式接口就是只定义一个抽象方法的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">boolean</span> <span class="title">test</span> <span class="params">(T t)</span></span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124152808596.png" alt="image-20220124152808596"></p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124153006513.png" alt="image-20220124153006513"></p>
<h4 id="5）使用案例-Consumer"><a href="#5）使用案例-Consumer" class="headerlink" title="5）使用案例 - Consumer"></a>5）使用案例 - Consumer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        forEach(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), (Integer i) -&gt; System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(T i : list)&#123;</span><br><span class="line">            c.accept(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124220459462.png" alt="image-20220124220459462" style="zoom: 50%;">

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124164410020.png" alt="image-20220124164410020"></p>
<h4 id="6）使用案例-Function"><a href="#6）使用案例-Function" class="headerlink" title="6）使用案例 - Function"></a>6）使用案例 - Function</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; map = map(Arrays.asList(<span class="string">&quot;asdxcvndf&quot;</span>, <span class="string">&quot;xcvxcv&quot;</span>, <span class="string">&quot;fghfgsdfsdfsdfsdfsdfh&quot;</span>), (String s) -&gt; s.length());</span><br><span class="line">        log.info(<span class="string">&quot;----&gt;&#123;&#125;&quot;</span>,map); <span class="comment">// [9, 6, 21]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; f)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; rs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T s : list)&#123;</span><br><span class="line">            rs.add(f.apply(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124170309472.png" alt="image-20220124170309472"></p>
<h4 id="7）java中的装箱和拆箱"><a href="#7）java中的装箱和拆箱" class="headerlink" title="7）java中的装箱和拆箱"></a>7）java中的装箱和拆箱</h4><p>​        装箱就是自动将<strong>基本数据类型转换为包装器类型</strong>；</p>
<p>​        拆箱就是自动将<strong>包装器类型转换为基本数据类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>java中装箱和拆箱操作是自动完成的。</p>
<p>下面的代码是有效的（<strong>一个int被装箱为Integer</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">300</span>; i &lt; <span class="number">400</span>; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这在性能方法是要付出代价的。<strong>装箱后的值本质上就是把原始类型包裹起来，并保存在堆中</strong>。因此，装箱后的值需要更多的内存，并需要额外的内存搜素来获取被包裹的原始值。<strong>所以在代码的编写中尽量不要进行装箱的操作</strong>。</p>
<p>函数式接口：</p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124172318086.png" alt="image-20220124172318086"></p>
<h4 id="8）类型检查、类型推断及限制"><a href="#8）类型检查、类型推断及限制" class="headerlink" title="8）类型检查、类型推断及限制"></a>8）类型检查、类型推断及限制</h4><h5 id="1）类型检查"><a href="#1）类型检查" class="headerlink" title="1）类型检查"></a>1）类型检查</h5><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220124172937998.png" alt="image-20220124172937998" style="zoom:50%;">



<h3 id="3、Lambda表达式二"><a href="#3、Lambda表达式二" class="headerlink" title="3、Lambda表达式二"></a>3、Lambda表达式二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Lambda 表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator = (a, b) -&gt; Integer.compare(a, b);</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、演变过程："><a href="#1、演变过程：" class="headerlink" title="1、演变过程："></a>1、演变过程：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 垃圾代码 --&gt; 策略模式 --&gt; 匿名内部类 --&gt; Lambda表达式</span><br></pre></td></tr></table></figure>

<h4 id="2、基础语法："><a href="#2、基础语法：" class="headerlink" title="2、基础语法："></a>2、基础语法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 操作符：-&gt;</span><br><span class="line">- 左侧：参数列表</span><br><span class="line">- 右侧：执行代码块 / Lambda 体</span><br></pre></td></tr></table></figure>

<p>语法格式一：无参数，无返回值    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(&quot;Hello lambda!&quot;)</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用Lambda表达式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runnable r1 = () -&gt; System.out.println(<span class="string">&quot;--r1--&quot;</span>);</span><br><span class="line">        r1.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、语法格式二"><a href="#3、语法格式二" class="headerlink" title="3、语法格式二"></a>3、语法格式二</h4><p>​    1）有一个参数，无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">       con.accept(<span class="string">&quot;张三牛逼！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    2）有一个参数，无返回值（小括号可以省略不写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Consumer&lt;String&gt; con = x -&gt; System.out.println(x);</span><br><span class="line">       con.accept(<span class="string">&quot;张三牛逼！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    3）有两个及以上的参数，有返回值，并且Lambda体中有多条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Comparator&lt;Integer&gt; comparator = (a,b) -&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> Integer.compare(a,b);</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    4）有两个及以上的参数，有返回值，并且Lambda体中只有1条语句（<strong>大括号与return都可以省略不写</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Comparator&lt;Integer&gt; comparator = (a,b) -&gt;Integer.compare(a,b);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lambda 表达式 参数的数据类型可以省略不写,因为JVM 编译器通过上下文推断出数据类型，可以自动进行 “类型推断”</strong></li>
</ul>
<h3 id="4、函数式接口"><a href="#4、函数式接口" class="headerlink" title="4、函数式接口"></a>4、函数式接口</h3><p>​        <strong>接口中只有一个抽象方法的接口就是函数式接口</strong>，可以使用**@FunctionalIterface**修饰，可以检测是否是函数式接口。</p>
<p>测试：</p>
<ul>
<li><p>定义一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Integer operation = operation(<span class="number">100</span>, x -&gt; x * x);</span><br><span class="line">       log.info(<span class="string">&quot;----:&#123;&#125;&quot;</span>,operation);</span><br><span class="line">       log.info(<span class="string">&quot;----:&#123;&#125;&quot;</span>,operation(<span class="number">200</span>,y -&gt; y + <span class="number">200</span>));</span><br><span class="line">       log.info(<span class="string">&quot;----:&#123;&#125;&quot;</span>,operation(<span class="number">50</span>,z -&gt; z + <span class="number">1000</span>));</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">operation</span><span class="params">(Integer num, MyFun mf)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mf.getValue(num);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>练习：</p>
<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220125152254775.png" alt="image-20220125152254775" style="zoom:50%;">

<p>1）第一题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = getList();</span><br><span class="line">      Collections.sort(list,(e1,e2) -&gt;&#123;</span><br><span class="line">          <span class="keyword">if</span>(e1.getAge() == e2.getAge())&#123;</span><br><span class="line">              <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> -Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">          System.out.println(employee);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2）第二题</p>
<ul>
<li>函数式接口定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="function">String <span class="title">getStr</span><span class="params">(String str)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandle</span><span class="params">(String str, MyFunction mf)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> mf.getStr(str);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">          String str1 = strHandle(<span class="string">&quot;sdfjndfg&quot;</span>, (str) -&gt; str.toUpperCase());</span><br><span class="line">          System.out.println(str1);</span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">  </span><br><span class="line">          String s = strHandle(<span class="string">&quot;  sdfnjnjsdfjhj   &quot;</span>, (str) -&gt; str.trim());</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3）第三题</p>
<ul>
<li><p>函数式接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun2</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="function">R <span class="title">getValue</span><span class="params">(T t1,T t2)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op</span><span class="params">(Long l1, Long l2, MyFun2&lt;Long,Long&gt; mf)</span></span>&#123;</span><br><span class="line">       System.out.println(mf.getValue(l1,l2));</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span>&#123;</span><br><span class="line">      op(<span class="number">100L</span>,<span class="number">200L</span>,(x,y) -&gt; x + y); <span class="comment">// 300</span></span><br><span class="line">      op(<span class="number">100L</span>,<span class="number">700L</span>,(x,y) -&gt; x * y); <span class="comment">// 70000</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5、Stream流及API使用"><a href="#5、Stream流及API使用" class="headerlink" title="5、Stream流及API使用"></a>5、Stream流及API使用</h3><h4 id="1、Stream的操作步骤"><a href="#1、Stream的操作步骤" class="headerlink" title="1、Stream的操作步骤"></a>1、Stream的操作步骤</h4><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127111927134.png" alt="image-20220127111927134" style="zoom:50%;">

<h4 id="2、筛选-切片"><a href="#2、筛选-切片" class="headerlink" title="2、筛选 / 切片"></a>2、筛选 / 切片</h4><p>中间操作：</p>
<ul>
<li>filter：接收 Lambda ，从流中排除某些元素</li>
<li>limit：截断流，使其元素不超过给定数量</li>
<li>skip(n)：跳过元素，返回一个舍弃了前n个元素的流；若流中元素不足n个，则返回一个空流；与 limit(n) 互补</li>
<li>distinct：筛选，通过流所生成的 hashCode() 与 equals() 取除重复元素</li>
</ul>
<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127112848023.png" alt="image-20220127112848023" style="zoom:50%;">

<p>中间操作：不会执行任何操作</p>
<p>终止操作：一次性执行全部内容，即“<strong>惰性求值</strong>”。</p>
<h5 id="2-1-filter-排除元素"><a href="#2-1-filter-排除元素" class="headerlink" title="2.1 filter: 排除元素"></a>2.1 filter: 排除元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = getList();</span><br><span class="line">    Stream&lt;Employee&gt; employeeStream = employees.stream().filter((e -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间操作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> e.getAge() &gt; <span class="number">35</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    employeeStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部迭代：迭代操作由Stream API完成</strong></p>
<p>外部迭代：我们通过迭代器完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部迭代</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       Iterator&lt;Employee&gt; iterator = employees.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-短路，提高效率"><a href="#2-2-短路，提高效率" class="headerlink" title="2.2 短路，提高效率"></a>2.2 短路，提高效率</h5><p>​    1、短路：是找到想要的数据后就不在找，这样可提高遍历的效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       employees.stream().filter((e) -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;短路！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> e.getSalay() &gt; <span class="number">5000</span>;</span><br><span class="line">                   &#125;).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127114751151.png" alt="image-20220127114751151"></p>
<p>以上“短路”只打印了两次，说明只遍历了两次操作，找到想要的数据后，就不在继续向下遍历了，可大大提高遍历的效率。</p>
<h5 id="2-3-distinct去重"><a href="#2-3-distinct去重" class="headerlink" title="2.3 distinct去重"></a>2.3 distinct去重</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = Arrays.asList(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">8999.99</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>, <span class="number">6787.99</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;jack&quot;</span>, <span class="number">56</span>, <span class="number">3849.90</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;mark&quot;</span>, <span class="number">38</span>, <span class="number">7648.99</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;mark&quot;</span>, <span class="number">38</span>, <span class="number">7648.99</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;mark&quot;</span>, <span class="number">38</span>, <span class="number">7648.99</span>),</span><br><span class="line">                <span class="keyword">new</span> Employee(<span class="string">&quot;mark&quot;</span>, <span class="number">38</span>, <span class="number">7648.99</span>));</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = getList();</span><br><span class="line">        employees.stream().filter((e) -&gt; e.getSalay() &gt; <span class="number">5000</span>).distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-映射"><a href="#2-4-映射" class="headerlink" title="2.4 映射"></a>2.4 映射</h5><ul>
<li>map：接收 Lambda ，将元素转换为其他形式或提取信息；接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>,<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        list.stream().map((str) -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">返回结果：</span><br><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line">CCC</span><br><span class="line">DDD    </span><br></pre></td></tr></table></figure>



<h5 id="2-5-排序"><a href="#2-5-排序" class="headerlink" title="2.5 排序"></a>2.5 排序</h5><ul>
<li><p>sorted()：自然排序</p>
</li>
<li><p>sorted(Comparator c)：定制排序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自然排序 - sort</span></span><br><span class="line"><span class="comment">    * sorted() - 自然排序（Comparable）</span></span><br><span class="line"><span class="comment">    * sorted(Comparator com) - 定制排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span>&#123;   </span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;ddd&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">       list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       employees.stream().sorted((e1,e2) -&gt;&#123;</span><br><span class="line">           <span class="keyword">if</span>(e1.getAge() == e2.getAge())&#123;</span><br><span class="line">               <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127143235706.png" alt="image-20220127143235706" style="zoom:33%;">

<h5 id="2-6-查找-匹配"><a href="#2-6-查找-匹配" class="headerlink" title="2.6 查找 / 匹配"></a>2.6 查找 / 匹配</h5><p>终止操作：</p>
<ul>
<li>allMatch：检查是否匹配所有元素</li>
<li>anyMatch：检查是否至少匹配一个元素</li>
<li>noneMatch：检查是否没有匹配所有元素</li>
<li>findFirst：返回第一个元素</li>
<li>findAny：返回当前流中的任意元素</li>
<li>count：返回流中元素的总个数</li>
<li>max：返回流中最大值</li>
<li>min：返回流中最小值</li>
</ul>
<p>1）检查相关操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查相关操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = getList();</span><br><span class="line">        <span class="keyword">boolean</span> b = employees.stream().allMatch((e) -&gt; e.getStatus().equals(Employee.Status.FREE));</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = employees.stream().anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.FREE));</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Employee&gt; op = employees.stream().sorted((e1,e2) -&gt; 		Double.compare(e1.getSalay(),e2.getSalay())).findFirst();</span><br><span class="line">        System.out.println(op.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream()</span><br><span class="line">                .filter((e) -&gt; e.getStatus().equals(Employee.Status.FREE))</span><br><span class="line">                .findAny();</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2）汇总、最大值和最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 最大值和最小值</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test02()&#123;</span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       long count = employees.stream().count();</span><br><span class="line">       System.out.println(count);</span><br><span class="line"></span><br><span class="line">       // 返回工资最大值的那条数据</span><br><span class="line">       System.out.println(&quot;--------------------&quot;);</span><br><span class="line">       Optional&lt;Employee&gt; employee = employees.stream().max((e1, e2) -&gt; Double.compare(e1.getSalay(), e2.getSalay()));</span><br><span class="line">       System.out.println(employee.get());</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;--------------------&quot;);</span><br><span class="line"></span><br><span class="line">       // 获取最小工资数：先map找到所有的工资，再从这些里面找到工资数最小的那个值</span><br><span class="line">       Optional&lt;Double&gt; op = employees.stream().map(Employee::getSalay).min(Double::compare);</span><br><span class="line">       System.out.println(op.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-7-规约-收集"><a href="#2-7-规约-收集" class="headerlink" title="2.7 规约 / 收集"></a>2.7 规约 / 收集</h5><p>1）reduce：可以将流中元素反复结合起来，得到一个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 规约：</span><br><span class="line">    *   reduce：可以将流中元素反复结合起来，得到一个值</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void test01()&#123;</span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class="line">       // 累加的过程</span><br><span class="line">       Integer reduce = list.stream().reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">       System.out.println(reduce);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;----------------------------&quot;);</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 计算员工集合中工资的总和</span><br><span class="line">        */</span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       // 因为可能工资可能为空，所有返回的是Optional类型，防止空指针异常</span><br><span class="line">       Optional&lt;Double&gt; reduce1 = employees.stream().map(Employee::getSalay).reduce(Double::sum);</span><br><span class="line">       System.out.println(reduce1.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2）收集：collect将流转换成其他形式；接收一个Collector接口的实现，用于给流元素做汇总方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 获取员工总数</span></span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       Long count = employees.stream().collect(Collectors.counting());</span><br><span class="line">       System.out.println(count);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 平均值</span></span><br><span class="line">       Double avg = employees.stream().collect(Collectors.averagingDouble(Employee::getSalay));</span><br><span class="line">       System.out.println(avg);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 总和</span></span><br><span class="line">       Double sum = employees.stream().collect(Collectors.summingDouble(Employee::getSalay));</span><br><span class="line">       System.out.println(sum);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最大值</span></span><br><span class="line">       Optional&lt;Employee&gt; max = employees.stream().collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalay(), e2.getSalay())));</span><br><span class="line">       System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最小值</span></span><br><span class="line">       Optional&lt;Double&gt; collect = employees.stream().map(Employee::getSalay).collect(Collectors.minBy(Double::compare));</span><br><span class="line">       System.out.println(collect.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; employees = getList();</span><br><span class="line">       <span class="comment">//根据状态分组</span></span><br><span class="line">       Map&lt;Employee.Status, List&lt;Employee&gt;&gt; collect = employees.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-8-并行流"><a href="#2-8-并行流" class="headerlink" title="2.8 并行流"></a>2.8 并行流</h5><ul>
<li><p>并行流：就是把一个内容分成几个数据块，并用不同的线程分别处理每个数据块的流</p>
</li>
<li><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行操作；Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与串行流之间切换</p>
</li>
<li><p>Fork / Join框架</p>
<p><img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127160855052.png" alt="image-20220127160855052"></p>
<p>Fork / Join 框架与传统线程池的区别：</p>
</li>
</ul>
<img src="/2022/01/24/java8%E5%AE%9E%E6%88%98%E4%B8%80/image-20220127160934359.png" alt="image-20220127160934359" style="zoom:50%;">]]></content>
  </entry>
</search>
